;; Classe qui représente une case de la grille de sudoku, elle a un numéro et est modifiable ou non
(defclass case-sudoku ()
  ((contenu :initarg :contenu :accessor contenu)
   (modifiable :initarg :modifiable :accessor modifiable)
   (valeurs-possibles :initform '() :initarg :valeurs-possibles :accessor coups-possibles))
  (:documentation "Case de la grille de sudoku"))

;; Grille du sudoku
(defclass grille-sudoku ()
  ((nb-lignes :initform 9 :reader nb-lignes)
   (nb-colonnes :initform 9 :reader nb-colonnes)
   (taille-carre :initform 3 :reader taille-carre)
   (nb-coups-restants :initform 0 :accessor nb-coups-restants)
   (tab :accessor tab :initform nil))
  (:documentation "Grille de jeu"))

(defgeneric init-grille (grille new-tab)
  (:documentation "Initialise les cases de la grille avec le tableau new-tab ainsi que le nombre de coups restants"))

(defgeneric jouer-coup (grille ligne colonne valeur)
  (:documentation "Modifie la case demandee avec la valeur donnee, si les arguments donnes sont valides"))

(defgeneric coup-valide (grille ligne colonne valeur)
  (:documentation "Détermine si le coup est valide"))

(defgeneric coup-valide-carre (grille ligne colonne valeur)
  (:documentation "Renvoie vrai si la valeur se trouve dans le carré de la case (ligne, colonne), hormis cette case"))

(defgeneric coordonnees-carre (grille ligne colonne)
  (:documentation "Renvoie une liste de de nombre qui sont les coordonnees du carre ou se trouve la case (ligne, colonne)"))

;; Initialisation des cases de la grille
;;   - avec le tableau d'entiers new-tab
;;   - si l'entier est égal à 0, la case n'est pas modifiable
;; Et initialisation du nombre de coups restants
(defmethod init-grille ((gr grille-sudoku) new-tab)
  (setf (tab gr) (make-array (list (nb-lignes gr) (nb-colonnes gr)) :initial-element nil))
  (setf (nb-coups-restants gr) (* (nb-lignes gr) (nb-colonnes gr))) 
  (dotimes (l (nb-lignes gr))
    (dotimes (c (nb-colonnes gr))
      (let ((contenu-case (aref new-tab l c)))
	(setf (aref (tab gr) l c)
	      (make-instance 'case-sudoku
			     :contenu contenu-case
			     :modifiable (= contenu-case 0)))
	(if (not (zerop contenu-case))
	    (decf (nb-coups-restants gr))))))
  (dotimes (l (nb-lignes gr))
    (dotimes (c (nb-colonnes gr))
      (if (modifiable (aref (tab gr) l c))
	  (do ((val 1 (1+ val)))
	      ((> val (nb-lignes gr)))
	    (if (coup-valide gr l c val)
		(setf (coups-possibles (aref (tab gr) l c))
		      (cons val (coups-possibles (aref (tab gr) l c))))))))))

;; Joue le coup demandé
(defmethod jouer-coup ((gr grille-sudoku) ligne colonne valeur)
  (dotimes (l (nb-lignes gr))
    (setf (coups-possibles (aref (tab gr) l colonne))
	  (remove valeur (coups-possibles (aref (tab gr) l colonne)))))
  (dotimes (c (nb-colonnes gr))
    (setf (coups-possibles (aref (tab gr) ligne c))
	  (remove valeur (coups-possibles (aref (tab gr) ligne c)))))
  (let* ((coor-carre (coordonnees-carre gr ligne colonne))
	 (ligne-carre (car coor-carre))
	 (colonne-carre (car (cdr coor-carre))))
    (dotimes (l (taille-carre gr))
      (dotimes (c (taille-carre gr))
	(let* ((ligne-a-verif (+ ligne-carre l))
	       (colonne-a-verif (+ colonne-carre c))
	       (case-a-verif (aref (tab gr) ligne-a-verif colonne-a-verif)))
	  (if (and (not (= ligne-a-verif ligne))
		   (not (= colonne-a-verif colonne)))
	      (setf (coups-possibles case-a-verif)
		    (remove valeur (coups-possibles case-a-verif))))))))
  (setf (coups-possibles (aref (tab gr) ligne colonne)) '())
  (setf (contenu (aref (tab gr) ligne colonne)) valeur))

;; Vérifie que la valeur qui veut être entrée dans la case (ligne, colonne) n'est pas présente dans le carré
(defmethod coup-valide-carre ((gr grille-sudoku) ligne colonne valeur)
  (let* ((coor-carre (coordonnees-carre gr ligne colonne))
	 (ligne-carre (car coor-carre))
	 (colonne-carre (car (cdr coor-carre)))
	 (coup-ok t))
    (dotimes (l (taille-carre gr))
      (dotimes (c (taille-carre gr))
	(let* ((ligne-a-verif (+ ligne-carre l))
	      (colonne-a-verif (+ colonne-carre c))
	      (contenu-a-verif (contenu (aref (tab gr) ligne-a-verif colonne-a-verif))))
	  (if (and (not (= ligne-a-verif ligne))
		   (not (= colonne-a-verif colonne))
		   (= contenu-a-verif valeur))
	      (setf coup-ok nil)))))
    coup-ok))

;; Détermine si la valeur n'est pas présente sur la ligne demandée, sur la colonne demandée ou dans le carré
(defmethod coup-valide ((gr grille-sudoku) ligne colonne valeur)
  (let ((valide t))
    (if (not (zerop valeur))
	(progn (do ((c 0 (1+ c))) ; parcours de la colonne
		   ((or (not valide) (>= c (nb-colonnes gr))))
		 (setf valide (not (= valeur (contenu (aref (tab gr) ligne c))))))
	       (if valide ; si la valeur entrée n'est pas présente sur la colonne
		   (do ((l 0 (1+ l))) ; on vérifie sur la ligne
		       ((or (not valide) (>= l (nb-lignes gr))) valide)
		     (setf valide (not (= valeur (contenu (aref (tab gr) l colonne)))))))
	       (if valide ; si la valeur entrée n'est pas présente sur la ligne et sur la colonne on vérifie dans le carré
		   (setf valide (coup-valide-carre gr ligne colonne valeur)))))
    valide))


;; Renvoie les coordonnées de la première case en haut à gauche du carré où se trouve la case spécifiée
(defmethod coordonnees-carre ((gr grille-sudoku) ligne colonne)
  (cons (* (do ((coef-ligne 0 (1+ coef-ligne)))
	       ((< (- ligne (* coef-ligne (taille-carre gr)))
		   (taille-carre gr))
		coef-ligne))
	   (taille-carre gr))
	(cons (* (do ((coef-colonne 0 (1+ coef-colonne)))
		     ((< (- colonne (* coef-colonne (taille-carre gr)))
			 (taille-carre gr)) coef-colonne))
		 (taille-carre gr))
	      '())))

(defmethod print-object ((gr grille-sudoku) stream)
  (format stream "   | A B C | D E F | G H I |~%")
  (format stream "****************************~%")
  (dotimes (i (nb-lignes gr))
    (if (and (> i 0) (= (mod i 3) 0))
	(format stream "****************************~%"))
    (format stream " ~A | " (1+ i))
    (dotimes (j (nb-colonnes gr))
      (if (and (> j 0) (= (mod j 3) 0))
	  (format stream "| "))
      (if (zerop (contenu (aref (tab gr) i j)))
	  (format stream "  ")
	  (format stream "~A " (contenu (aref (tab gr) i j))))
      (if (= j 8)
	  (format stream "|~%"))))
  (format stream "****************************~%"))

;; Création de la grille de jeu
(defparameter *grille* (make-instance 'grille-sudoku))

;; Définition de la boucle while
(defmacro while (test &rest body)
  `(do ()
       ((not ,test))
     ,@body))

(defun strat-case-un-coup-possible ()
  ;;Cases avec qu'un coups possible
  (let ((ligne-case nil)
	(colonne-case nil)
	(valeur-case nil)
	(l 0)
	(c 0)
	(case-trouvee nil))
    (while (and (not case-trouvee)
		(< l (nb-lignes *grille*)))
      (while (and (not case-trouvee)
		  (< c (nb-colonnes *grille*)))
	(let ((case-a-verifiee (aref (tab *grille*) l c)))
	  (if (and (modifiable case-a-verifiee)
		   (= (length (coups-possibles case-a-verifiee)) 1))
	      (progn (setf case-trouvee t)
		     (setf ligne-case l)
		     (setf colonne-case c)
		     (setf valeur-case (car (coups-possibles case-a-verifiee)))))
	  (incf c)))
      (incf l))
    (if case-trouvee
	(progn (jouer-coup *grille* ligne-case colonne-case valeur-case)
	       (values ligne-case colonne-case valeur-case))
	nil)))

(defun strat-seule-possilite-dans-carre ()
  (let ((nb-carre-par-ligne (/ (nb-lignes *grille*) (taille-carre *grille*)))
	(nb-carre-par-colonne (/ (nb-colonnes *grille*) (taille-carre *grille*)))
	(numcarre-ligne 0)
	(numcarre-colonne 0)
	(case-trouvee nil)
	(valeurs (make-array 9 :initial-element 0))
	(li-valeurs-finale nil)
	(ligne-case-a-changer 0)
	(colonne-case-a-changer 0))
    (while (and (< numcarre-ligne nb-carre-par-ligne) (not case-trouvee))
      (setf numcarre-colonne 0)
      (while (and (< numcarre-colonne nb-carre-par-colonne) (not case-trouvee))
	(dotimes (l (taille-carre *grille*))
	  (dotimes (c (taille-carre *grille*))
	    (let* ((ligne-a-verif (+ (* numcarre-ligne (taille-carre *grille*)) l))
		   (colonne-a-verif (+ (* numcarre-colonne (taille-carre *grille*)) c))
		   (case-a-verifier (aref (tab *grille*) ligne-a-verif colonne-a-verif)))
	      (mapcar (lambda (x) (incf (aref valeurs (1- x)))) (coups-possibles case-a-verifier)))))
	(setf li-valeurs-finale (map 'list (lambda (x) x) valeurs))
		
	(if (= 1 (length (remove-if-not (lambda (x) (= x 1)) li-valeurs-finale)))
	    (let ((l 0)
		  (c 0))
	      (while (and (< l (taille-carre *grille*)) (not case-trouvee))
		(setf c 0)
		(while (and (< c (taille-carre *grille*)) (not case-trouvee))
		  (setf ligne-case-a-changer (+ (* numcarre-ligne (taille-carre *grille*)) l))
		  (setf colonne-case-a-changer (+ (* numcarre-colonne (taille-carre *grille*)) c))
		  (setf case-trouvee (position (1+ (position 1 li-valeurs-finale))
					       (coups-possibles (aref (tab *grille*) ligne-case-a-changer colonne-case-a-changer))))
		  (incf c))
		(incf l)))
	    (setf valeurs (make-array 9 :initial-element 0)))
	(incf numcarre-colonne))
      (incf numcarre-ligne))
    (if case-trouvee
	(progn (jouer-coup *grille* ligne-case-a-changer colonne-case-a-changer (1+ (position 1 li-valeurs-finale)))
	       (values ligne-case-a-changer colonne-case-a-changer (1+ (position 1 li-valeurs-finale))))
	nil)))

(defun init-standalone (grid)
  (init-grille *grille* grid))

(defun main-standalone ()
  (if (not (strat-case-un-coup-possible))
      (strat-seule-possilite-dans-carre)))
  
(defun afficher ()
  (dotimes (l (nb-lignes *grille*))
    (dotimes (c (nb-colonnes *grille*))
      (format t "(~A;~A) : ~A~%" l c (coups-possibles (aref (tab *grille*) l c))))))
  
	
